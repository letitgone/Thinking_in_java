# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 7: 复用类
1.在新类中产生现有类的对象，由于新类是由现有类的对象组成的，所以这种方法称为组合，该方法只是复用了现有程序代码的功能，
而非它的形式。   
2.按照现有类的类型来创建新类，无需改变现有类的形式，采用现有类的形式并在其中添加新代码，这种方式叫做继承。   
3.就组合和继承而言，其语法和行为大多是相似的。
### 7.1 组合语法
1.toString(),每一个非基本类型的对象都有一个toString()方法，而且当编译器需要一个String而你却只有一个对象时，该方法
便会被调用。   
2.编译器并不是简单地为每一个引用都创建默认对象，这一点是很有意义的，因为若真要那样做的话，就会在许多情况下增加不必要
的负担，如果想初始化这些引用，可以在代码中的下列位置进行：   
(1)在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化；   
(2)在类的构造器中；   
(3)就在正要使用这些对象之前，这种方法称为惰性初始化，在生成对象不值得及不必每次都生成对象的情况下，这种方法可以减少
额外的负担；   
(4)使用实例初始化。（demo:Bath.java）。   
### 7.2 继承语法
1.当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。   
2.为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public。   
3.Java用super关键字表示超类的意思，表达式super.scurb()将调用基类版本的scrub()方法。   
4.当创建了一个导出类的对象时，该对象包含了一个基类的子对象，这个子对象与你用基类直接创建的对象是一样的。二者区别在于，
后者来自于外部，而基类的子对象被包装在导出类对象内部。   
5.Java会自动在导出类的构造器中插入对基类构造器的调用。   
6.基类在导出类构造器可以访问它之前，就已经完成了初始化，即使你不为Cartoon()创建构造器，编译器也会为你合成一个默认的
构造器，该构造器将调用基类的构造器。   
7.调用基类构造器必须是你在导出类构造器中要做的第一件事情。   
### 7.3 代理
1.运用继承就是子类直接调用基类的方法，而代理就是没有继承关系也可以调用，引用+.来调用对应方法。
### 7.4 结合使用组合和继承
1.try...finally:关键字try表示，下面的块（用一组大括号括起来的范围）是所谓的保护区，这意味着它需要被特殊处理，其中
一项特殊处理就是无论try块是怎样退出的，保护区后的finally子句中的代码总要被执行。   
2.执行类的所有特定的清理动作，其顺序同生成顺序相反（通常这就要求基类元素仍旧存活）。   
3.进行清理，最好是编写自己的清理方法，但不要使用finalize()。   
4.Override:使用与基类完全相同的特征签名及返回类型来覆盖具有相同名称的方法。   
5.JavaSE5新增了@Override注解，它并不是关键字，但是可以把它当作关键字用，它可以防止你在不想重写时而意外地进行了重写。 
注：  
(1)重载(Overload):重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重
载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。   
(2)重写(Override):重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心
重写！
### 7.5 在组合和继承之间选择
1.组合通常用于想在新类中使用现有类的功能而非它的接口这种情形，即，在新类中嵌入某个对象，让其实现所需要的功能
2."is-a"（是一个）的关系是用继承来表达的，而"has-a"（有一个）的关系是用组合来表达的。   
### 7.6 protected关键字
1.对于任何继承于此类的导出类或者其他任何位于同一个包内的类来说，它是可以访问的，（protected提供了包访问权限）。   
### 7.7 向上转型
1.将导出类引用转换为基类引用的动作，我们称之为向上转型。   
2.由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。（麻雀是鸟）   
3.到底是该使用组合还是继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型，如果必须要向上转型，
则继承是必要的。   
4.Amphibian a = new Frog2(); a.xxxx; 调用的是导出类的方法，如果导出类没有，则调用基类的方法。   
### 7.8 final关键字
1.final的含义：这是无法改变的。   
2.final可能使用的三种情况：数据，方法和类。   
3.对于基本对象，final使数值恒定不变，而用于对象引用，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把
它改成指向另一个对象，这一限制同样适用于数组，它也是对象（即使static的，又是final的域，即编译期常量，将用大写表示）。   
4.Java允许生成"空白final"，所谓空白final是指被声明为final但又未给定初始值的域。   
5.Java允许在参数列表中以声明的方式将参数指明为final，这意味着你无法在方法中更改参数引用所指向的对象，这一特性主要用
来向匿名内部类传递数据。   
6.使用final方法的原因：把方法锁定，以防任何继承类修改它的含义，这是出于设计考虑，想要确保在继承中使方法行为保持不变，
并且不会被覆盖。   
7.类中所有的private方法都隐式地指定为final的，可以对private方法添加final修饰词，但这并不能给该方法增加任何额外的
意义。   
8."覆盖"只有在某方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法，如果某
方法是private，它就不是基类的接口的一部分，如果在导出类中以相同的名称生成一个public，protected或者包访问控制权限
方法的话，该方法就不会产生在基类中出现的"仅具有相同名称"的情况，此时你并没有覆盖该方法，仅是生成了一个新的方法。   
9.当将某个类的整体定义为final时（通过将关键字final置于它的定义之前），就表明了你不打算继承该类，而且也不允许别人这么
做，在final类中可以给方法添加final修饰词，但这并不会增添任何意义。   
### 7.9 初始化及类的加载
1.每个类的编译代码都存在于它自己的独立文件中，该文件只在需要使用程序代码时才会被加载，加载发生于创建类的第一个对象之
时，但是当访问static域或static方法时，也会发生加载。   
2.构造器也是static方法，尽管static没有显示地写出来，因此更准确的讲，类是在其任何static成员被访问时加载的。   
3.初次使用之处也是static初始化发生之处，所有的static对象和static代码段都会在加载时依程序中定义的顺序依次初始化，
当然定义为static的东西只会被初始化一次。   

