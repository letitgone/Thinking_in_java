# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 11: 持有对象
1.Java实用类库还提供了一套相当完整的容器类来解决这个问题，其中基本的类型是List，Set，Queue，Map，这些对象类型也称
为集合类，但由于Java的类库中使用了Collection这个名字来指代该类库的一个特殊子集，所以我们使用了范围更广的术语"容器"
称呼他们。  
2.Java容器都可以自动的调整自己的尺寸。
### 11.1 泛型和类型安全的容器
1.@SuppressWarnings注解及其参数表示只有有关"不受检查的异常"的警告信息应该被抑制。   
2.如果一个类没有显示地声明继承自哪个类，那么它自动地继承自Object。   
3.List没有指定类型，所以所有的Apple都是Object，get的时候必须进行类型强制转换，当你试图将Orange对象转型为Apple时，
你就会以前面提及的异常的形式得到一个错误。   
4.尖括号括起来的是类型参数（可以有多个），它指定了这个容器实例可以保存的类型，通过使用泛型，就可以在编译期防止将错误
类型的对象放置到容器中。   
5.List使用泛型能使错误从编译器错误变成运行时错误。   
### 11.2 基本概念
1.Java容器类类库的用途是"保存对象"，并将其划分为两个不同的概念：   
1)Collectiion:一个独立元素的序列，这些元素都服从一条或多条规则，List必须按照插入的顺序保存元素，而Set不能有重复的
元素，Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。   
2)Map：一组成对的"键值对"对象，允许你使用键来查找值。
3.Collection接口概括了序列的概念---一种存放一组对象的方式。   
### 11.3 添加一组元素
1.Collection是集合类的上级接口，继承与他有关的接口主要有List和Set。Collections是针对集合类的一个帮助类，他提供一
系列静态方法实现对各种集合的搜索、排序、线程安全等操作。   
2.Arrays.asList用来将数组转化为List。
### 11.4 容器的打印
1.Java容器类库中的两种主要类型：   
1)List，它以特定的顺序保存一组元素；Set，元素不能重复；Queue，只允许在容器的一端插入对象，并从另一端移除对象。   
2)Map在每个槽内保存了两个对象，即键和与之相关的值。   
它们的区别在于容器中每个"槽"保存的元素个数。   
2.Collection打印出来用方括号括住，每个元素由逗号隔开，[rat, cat, dog, dog]，Map则用大括号括住，键与值由等号连接
{rat=Fuzzy, cat=Rags, dog=Spot}。   
3.ArrayList,LinkedList：LinkedList包含的操作多于ArrayList。
4.HashSet,TreeSet,LinkedHashSet：HashSet是获取元素最快的方式
5.HashMap,TreeMap,LinkedHashMap：HashMap提供了最快的查找技术，没有按照任何明显的顺序来保存元素，TreeMap按照比较
结果的升序保存键，而LinkedHashMap则按照插入顺序保存键，同时还保留了HashMap的查询速度。   
### 11.5 List
1.两种类型的List：   
1)基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时比较慢。   
2)LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问，LinkedList在随机访问方面相对
比较慢，但是它的特性集较ArrayList更大。
### 11.6 迭代器
1.迭代器也是一种设计模式。   
2.迭代器是一个对象，他的工作是遍历并选择序列中的对象，它通常被称为轻量级对象：创建它的代价小
3.Java的Iterator只能单向移动，这个Iterator只能用来：   
1)使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。   
2)使用next()获取序列中的下一个元素。   
3)使用hasNext()检查序列中是否还有元素。   
4)使用remove()将迭代器新建返回的元素删除。   
4.Iterator能够将遍历序列的操作与序列底层的结构分离，迭代器统一了对容器的访问方式。   
5.ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问，尽管Iterator只能向前移动，但是ListIterator
可以双向移动，它还可以产生相对与迭代器在列表中的指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换
它访问过的最后一个元素。   
6.你可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且可以通过调用listIterator(n)方法创
建一个一开始就指向列表索引为n的元素处的ListIterator。   
### 11.7 LinkedList
1.LinkedList执行插入和移除擦耦走比ArrayList更高效，但是在随机访问操作方面却要逊色一些。   
### 11.8 Stack
1."栈"通常是指"后进先出"（LIFO）的容器。有时栈也被称为叠加栈，因为最后"压入"栈的元素，第一个"弹出"栈。   
2.LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。   
3.类名之后的<T>告诉编译器这将是一个参数化类型，而其中类型参数，即在类被使用时将会被实际类型替换的参数，就是T。大体上，
这个类是在声明"我们定义一个可以持有T类型对象的Stack"。   
4.如果你想在自己的代码中使用这个Stack类，当你在创建其实例时，就需要完整指定包名，或者更改这个类的名称，否则，就可能
与java.util包中的Stack发生冲突。   
### 11.9 Set
1.Set不保存重复的元素，如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复现象。   
2.查找时Set中最重要的操作，因此你通常都会选择一个HashSet的实现，它专门对快速查找进行了优化。   
3.Set具有与Collection完全一样的接口，因此没有任何额外的功能，实际上Set就是Collection，只是行为不同，这是继承与多态
思想的典型应用：表现不同的行为。   
4.HashSet所维护的顺序与TreeSet或LinkedHashSet都不一样，因为它们的实现具有不同的元素存储方式。TreeSet是将元素存储
在红-黑数数据结构中，而HashSet使用的是散列函数，LinkedHashSet使用了链表来维护元素的插入顺序。   
### 11.10 Map
1.将对对象映射到其他对象的能力是一种解决编程问题的杀手锏。   
2.Map很容易扩展到多维，只需要将其值设置为Map(这些Map的值可以是其他容器，甚至是其他Map)。
### 11.11 Queue
1.队列是一个典型的先进先出（FIFO）的容器，即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是
相同的，队列常被当作一种可靠的的将对象从程序的某个区域传输到另一个区域的途径，队列在并发编程中特别重要。   
2.LinkedList实现了Queue接口。   
3.offer()方法是Queue相关的方法之一，它在允许的情况下，将一个元素插入到队尾，或者返回false。   
4.peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，而element()会抛出NoSuchElementException
异常。   
5.poll()和remove()方法将移除并返回对头，但是poll()在队列为空时返回null，而remove()会抛出NoSuchElementException。   
6.Queue接口窄化了对LinkedList的方法的访问权限，因此你能够访问的LinkedList的方法会变少。   
7.先进先出描述了最典型的队列规则，队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则，先进先
出声明的是一个元素应该是等待时间最长的元素。   
8.优先级队列声明一个弹出元素是最需要的元素（具有最高的优先级）。   
9.优先级队列算法通常会在插入时排序（维护一个堆）。   
10.当你在PriorityQueue上调用offer()方法插入一个对象时，这个对象会在队列中被排序，默认的排序将使用对象在队列中的自
然顺序，但是你可以通过提供自己的Comparator来修改这个顺序。   
11.PriorityQueue允许重复，最小的值拥有最高的优先级，如果是String，空格也可以算作值，并且比字母的优先级高。   
### 11.12 Collection和Iterator
1.Collection是描述所有序列容器的共性的根接口，它可能被认为是一个"附属接口"，即因为要表示其他若干个接口的共性而出现
的接口。   
2.生成Iterator是将队列与消费队列的方法连接在一期耦合度最小的方式，并且与实现
Collection相比，他在序列类上所施加的约束也少的多。
### 11.13 Foreach与迭代器
1.Foreach主要用于数组，但是它也可以应用于任何的Collection对象，之所以能够这样是因为JavaSE5引入的Iterable的接口。   
2.尝试把数组当作一个Iterable参数传递会导致失败，这说明不存在任何从数组到Iterable的自动转换，你必须手动执行这种转换。  
### 总结 
![Image text](src/main/resources/image/Container.jpg)
1.容器不能持有基本类型，但是自动包装机制会执行基本类型到容器中所持有的包装器类型之间的双向转换。   
2.如果要进行大量的随机访问，就使用ArrayList，如果要经常从表中插入，删除元素，则应该使用LinkedList。   
3.各种Queue以及栈的行为，由LinkedList提供支持。   
4.Map是一种将对象（而非数字987654）与对象相关联的设计，HashMap设计用来快速访问，TreeMap保持"键"始终处于排序状态，所以没有
HashMap快，LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。   
5.Set不接受重复元素，HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保持元素。   
6.容器只有四种，List,Set,Map,Queue,常用的容器用黑色方框表示，点线框表示接口，实线框表示类，带有空心箭头的点线表示
一个特定的类实现了一个接口，实心箭头表示某个类可以生成箭头所指向的类的对象。
