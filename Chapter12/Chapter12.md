# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 12: 通过异常处理错误
1.Java的基本理念是"结构不佳的代码不能运行"。   
2.发现错误的理想时机是在编译阶段，也就是在你试图运行之前，然而，编译期间并不能找出所有的错误，余下的问题必须在运行期
间解决，这就需要错误源能通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确处理这个问题。  
3.改进的错误恢复机制是提供代码健壮性的最强有力的方式，Java通过异常来提供一致的错误报告模型，使得构建能够与客户端代码
可靠地沟通问题。
### 12.1 概念
1.用强制规定的形式来消除错误处理过程中随心所欲的因素。
### 12.2 基本异常
1.当抛出异常后，有几件事会随之发生：   
1）首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象；   
2）然后，当前的执行路径（它不能继续下去了）被终止，并且从当前环境中弹出队异常对象的引用，此时，异常处理机制接管程序，
并开始寻找一个恰当的地方来执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换
一种方式运行，要么继续运行下去。   
2.对于对象引用t，传给你的时候可能尚未初始化，所以在使用这个对象引用调用其方法之前，会先对引用进行检查，可以创建一个代
表错误信息的对象，并且将它从当前环境中"抛出"，这样就把错误信息传播到了"更大"的环境中，这称为抛出一个异常：
```
if(t == null){
    throw new NullPointerException();
}
```
这就抛出了异常，于是当前环境下就不必再为这个问题操心了，他将在别的地方得到处理。   
3.所有标准异常类都有两个构造器：一个默认构造器，另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：
```
throw new NullPointerException("t == null");
```
4.在使用new创建了异常对象之后，此对象的引用将传给throw，另外还能用抛出异常的方式从当前的作用域退出。   
5.异常返回的"地点"与普通方法调用返回的"地点"完全不同，异常将在一个恰当的异常处理程序中得到解决，它的位置可能离异常被
抛出的地点很远，也可能会跨越方法调用栈的许多层次。   
6.能够抛出任意类型的Throwable对象，它是异常类型的根类，错误信息可以保存在异常对象内部或者用异常类的名称来暗示，通常
异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。
### 12.3 捕获异常
1.要明白异常是如何被捕获的，必须先理解监控区域（guarded region）：它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。   
2.如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束，要是不希望方法
就此结束，可以在方法内设置一个特殊的块来捕获异常，因为在这个块里"尝试"各种（可能产生异常的）方法调用，所以称为try块。   
3.抛出的异常必须在某处得到处理，这个"地点"就是异常处理程序。   
4.try...catch
```
try {
  // Code that might generate exceptions
} catch(Type1 id1)|{
  // Handle exceptions of Type1
} catch(Type2 id2) {
  // Handle exceptions of Type2
} catch(Type3 id3) {
  // Handle exceptions of Type3
}

```
每个catch子句（异常处理程序）看起来就像是接收一个且仅接收一个特殊类型的参数的方法，可以在处理程序的内部使用标识符（
id1，id2等等），这与方法参数的使用狠相似，有时可能用不到标识符，因为异常的类型已经给了你足够的信息来对异常进行处理，
但是标识符并不可以省略。   
5.异常处理程序必须紧跟在try块之后，当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序，然后
进入catch子句执行，此时认为异常得到了处理，一旦catch子句结束，则处理程序的查找过程结束，注意，只有匹配的catch子句
才能得到执行，这与switch语句不同，switch语句需要子啊每一个case后面跟一个break，以避免执行后续的case子句。注意在
try块内部，许多不同的方法调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。   
6.异常处理理论上有两种基本模型：   
1）Java支持终止模型：在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就
表明错误已无法挽回，也不能回来继续执行。
2）恢复模型：意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功，对于恢复模型，通常
希望异常被处理之后能继续执行程序。 (把try块放在while循环里)  
### 12.4 创建自定义异常
1.要自己定义异常类，必须从已有的异常类继承，最好选择意思相近的异常类继承
### 12.5 异常说明
1.异常说明使用了附加的关键字throws。   
2.在编译时被强制检查的异常称为被检查的异常。
### 12.6 捕获所有异常
1.可以只写一个异常处理程序来捕获所有异常的类型，通过捕获异常类型的基类Exception就可以做到这一点。
```
catch(Execption e){
    System.out.println("Caught an exception");
}
```
2.printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问。   
3.重抛异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略，此外，异常对象的所有信息都得以
保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。   
4.如果只把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的
信息。   
5.在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这被称为异常链，所有的Throwable的子类在构造器中都
可以接受一个cause（因由）对象作为参数，这个cause就用来表示原始异常，这样通过把原始异常传递给新异常，使得即使在当前
位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。   
6.Throwable子类中，只有三种基本异常类提供了带cause参数的构造器，它们是：Error(用于Java虚拟机报告系统错误)，
Exception以及RuntimeException，如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。   
### 12.7 Java标准异常
1.Throwable这个Java类被用来表示任何可以作为异常被抛出的类，Throwable对象可分为两种类型（指从Throwable继承而得到
的类型）：Error用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；Exception是可以被抛出的基本类型，在Java类
库，用户方法以及运行时故障中都可能抛出Exception型异常，所以Java程序员关心的基本类型通常是Exception。      
2.对异常来说，关键是理解概念以及如何使用，异常的基本概念是用名称代表发生的事情，并且异常的名称应该是望文知意。   
3.属于运行时异常的类型有很多，它们会自动被Java虚拟机抛出。   
4.RuntimeException（或任何从它继承的异常）是一个特例，编译器不需要异常说明，其输出别报告给System.err。   
5.如果RuntimeException没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法。   
6.究其原因，RuntimeException代表的是编程错误。   
### 12.8 使用finally进行清理
1.对于一些代码，可能会希望无论try块中的异常是否抛出，它们都能得到执行，为了达到这个效果，可以在异常处理程序后面加上
finally子句，like this:
```
try {
      // The guarded region: Dangerous activities
      // that might throw A, B, or C
    } catch(A a1) {
      // Handler for situation A
    } catch(B b1) {
      // Handler for situation B
    } catch(C c1) {
      // Handler for situation C
    } finally {
      // Activities that happen every time
}
```
2.当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句，这种需要清理的资源包括：已经打开的文件或网络连
接，在屏幕上画的图形，甚至可以是外部世界的某个开关。   
3.--
```
try {
        // With return in the middle...
        System.out.println("111"); --------1
        return; ---------------------------3
    } finally {
        frog.dispose(); -------------------2
    }
```
执行顺序1，2，3。
### 12.9 异常的限制
1.当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。   
2.派生类构造器的异常说明必须包含基类构造器的异常说明，派生类的构造器不能捕获基类构造器抛出的异常。   
3.通过强制派生类遵守基类方法的异常说明，对象的可替换性得到了保证。   
4.派生类方法可以不抛出任何异常，即使它是基类所定义的异常。   
5.不能基于异常说明来重载方法，此外一个出现在基类方法的异常说明中的异常，不一定会出现在派生类方法的异常说明里，这与类
的继承刚好相反。   
### 12.10 构造器
1.对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式就是使用嵌套的try子句。
### 12.11 异常匹配
### 12.12 其他可选方式
1.开发异常处理的初衷是为了方便程序员处理错误。   
2.异常处理的原则是，只有在你知道如何处理的情况下才捕获异常。   
3.异常说明有两种意思：一个是我的代码会产生这种异常，这由你来处理，另一个是，我的代码忽略了这些异常，这由你来处理。   
### 12.13 异常使用指南
1.应该在下列情况下使用异常：   
1)在恰当地级别处理问题（在知道该如何处理的情况下才捕获异常）；   
2)解决问题并且重新调用生产异常的方法；   
3)进行少许修补，然后绕过异常发生的地方继续执行；   
4)用别的数据进行计算，以代替方法预计会返回的值；   
5)把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层；   
6)把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层；   
7)终止程序；   
8)进行简化（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人）；   
9)让类库和程序更安全（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资）；
