# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 14 类型信息
1.运行时类型信息使得你可以在程序运行时发现和使用类型信息。   
2.Java在运行时识别对象和类的信息主要有两种方式：一种是"传统的"RTTI（Run-Time Type Identification），它假设我们在编译时已经知道了所有的类型；另一种
是"反射"机制，它允许我们在运行时发现和使用类的信息。   
### 14.1 为什么需要RTTI
1.Java所有的类型转换都在运行时进行正确性检查，这也是RTTI名字的含义：在运行时，识别一个对象的类型。   
### 14.2 Class对象
1.Java使用Class对象来执行其RTTI。   
2.类是程序的一部分，每个类都有一个Class对象，换言之，每当编写并且编译了一个新类，就会产生一个Class对象，更恰当的说，
是被保存在一个同名的.Class文件中，为了生成这个类的对象，运行这个程序的Java虚拟机(JVM)将使用被称为"类加载器"的子系统。   
3.类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分，原生类加载器加载的是所谓
的可信类，包括Java API类，他们通常是从本地盘加载的。   
4.所有的类都是在对其第一次使用时，动态加载到JVM中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类，这个证明
构造器也是类的静态方法，即使在构造器之前并没有使用static关键字，因此使用new操作符创建类的新对象也会被当作对类的静态
成员的引用。   
5.类加载器首先检查这个类的Class对象是否已经加载，如果没有，默认的类加载器就会根据类名查找.class文件，在这个类的字节
码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良的Java代码，一旦某个类的Class对象被载入内存，它就被用
来创建这个类的所有对象。   
6.Class对象仅在需要的时候才被加载，static初始化是在类加载时进行的。    
7.Java提供了另一种方法来生成对Class对象的引用，即使用类字面常量，like this：FancyToy.class，类字面常量不仅可以
应用于普通类，也可以应用于接口，数组以及基本数据类型，另外对于基本数据类型的包装器类，还有一个标准字段TYPE，TYPE字段
是一个引用，指向对应的基本数据类型的Class对象:   
boolean.class 等价于 Boolean.TYPE，其他包装器类一样。  
8.使用".class"来创建对Class对象的引用时，不会自动地初始化该Class对象。   
9.为了使用类而做的准备工作实际包含三个步骤:
1)加载，这是由类加载器执行的。该步骤将查找字节码(通常在classpath所指定的路径中查找，但这并非是必需的)，并从这些字节
码中创建一个Class对象。   
2)链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。   
3)初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。   
10.如果一个static final值是"编译期常量"，就像Initable.staticFinal那样，那么这个值不需要对就像Initable类进行初
始化就可以被读取，但是，如果只是将一个域设置成static和final的，那还不足以确保这种行为，例如，对Initable.staticFinal2
的访问将强制进行类的初始化，因为它不是一个编译器常量。   
11.Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码，它还包含该类的静态成员，
因此，Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。   
12.为了在使用泛化的Class引用时放松限制，我使用了通配符，它是Java泛型的一部分，通配符就是"?"，表示"任何事物"。   
```java
public class WildcardClassReferences {
  public static void main(String[] args) {
    Class<?> intClass = int.class;
    intClass = double.class;
  }
}
```   
```java
public class BoundedClassReferences {
  public static void main(String[] args) {
    Class<? extends Number> bounded = int.class;
    bounded = double.class;
    bounded = Number.class;
    // Or anything else derived from Number.
}
}
```
### 14.3 类型转换前先做检查
1.迄今为止，我们已知的RTTI形式包括：   
1)传统的类型转换，如"(Shape)"，有RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。   
2)代表对象的类型的Class对象，通过查询Class对象可以获取运行时所需的信息。   
3)关键字instanceof：它返回一个布尔值，告诉我们对象是不是某个特定类型的实例，可以用提问的方式使用它，like this：
```
if(x instanceof Dog){
    ((Dog)x).bark();
}
```   
x是否从属于Dog类
2.@SuppressWarnings注解是jse提供的注解。作用是屏蔽一些无关紧要的警告。使开发者能看到一些他们真正关心的警告。从而
提高开发者的效率。
### 14.4 注册工厂
### 14.5 instanceof与Class的等价性
1.instanceof保持了类型的概念，它指的是"你是这个类吗，或者你是这个类的派生类吗？"而如果使用==比较实际的Class对象，
就没有考虑继承--它或者是这个确切的类型，或者不是。
### 14.6 反射：运行时的类信息
1.如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，
换句话说，在编译时，编译器必须知道所有要通过RTTI来处理的类。   
2.RTTI和反射之间的区别：对RTTI来说，编译器在编译时打开和检查.class文件，换句话说，我们可以用普通方式调用对象的所有
方法，而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时代开和检查.class文件。   
### 14.7 动态代理
1.动态代理提供了额外的或不同的操作，而插入的用来代替"实际"对象的对象，这些操作通常涉及与"实际"对象的通信，因此代理通
常充当着中间人的角色。
### 14.8 空对象
### 14.9 接口与类型信息
