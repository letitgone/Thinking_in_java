# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 17 容器深入研究
### 17.1 完整的容器分类法
### 17.2 填充容器
### 17.3 Collection的功能方法
### 17.4 可选操作
### 17.5 List的功能方法
### 17.6 Set和存储顺序
![Image text](src/main/resources/image/Set.jpeg)
### 17.7 队列
### 17.8 理解Map
1.性能：当使用get()中使用线性搜索时，执行速度会非常地慢，HashMap使用了特殊的值，称作散列码hashCode，来取代对键值
缓慢搜索。   
2.hashCode()是根类Object的方法，因此所有Java对象都能产生散列码，HashMap就是使用对象的hashCode()进行快速查询的，
此方法能够显著提高性能。如果这仍然不能满足你对性能的要求，可以创建自己的Map来提高查询速度，并且令新的Map只针对你使用
的特定类型，这样可以避免与Object之间的类型转换操作，要达到更高的性能，使用数组代替溢出桶，这有两个好处：一：可以针对
磁盘存储方式做优化，第二：在创建和回收单独的记录时，能节约很多时间。   
3.![Image text](src/main/resources/image/Map.jpeg)
### 17.9 散列与散列码
1.如果不为你的键覆盖hashCode()和equals()，那么使用散列的数据结构就无法正确处理你的键。   
2.使用散列的目的在于：想要使用一个对象来查找另一个对象。   
3.散列则更进一步，它将键保存在某处，以便能够快速找到，存储一组元素最快的数据结构是数组，所有使用它来表示键的信息（键
信息，不是键本身），但是因为数组不能调整容量，因此就有一个问题：我们希望在Map中保存数量不确定的值，但是如果键的数量
被数组的容量限制了，该怎么办？答案就是：数组并不保存键本身，而是通过键对象生成一个数字，将其作为数组的下标，这个数字
就是散列码，于是查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。    
4.hashCode()生成的结果，经过处理后成为桶位的下标。   
5.无论何时，对同一对象调用hashCode()都应该生成同样的值，如果在将一个对象用put()添加进HashMap时产生一个hashCode()
值，而调用get()取出时却产生了另一个hashCode()值，那么就无法重新取得该对象，对于String而言，hashCode()明显是基于
String的内容的。   
6.散列码不必是独一无二的（应该更关注生成速度，而不是唯一性），但是通过hashCode()和equals()必须能够完全确认对象的身
份。（hashCode是int）   
7.好的hashCode()应该产生均匀分布的散列码，如果散列码都集中在一块，那么HashMap或HashSet在某些区域的负载会很重，这样
就不如分布均匀的散列函数快。   
### 17.10 选择接口的不同实现
1.ArrayList在插入时，必须创建空间并将它的所有引用向前移动，这会随着ArrayList的尺寸增加而产生高昂的代价，LinkedList
只需要链接新的元素，而不必修改列表中剩余的元素，因此你可以认为无论列表尺寸如何变化，其代价大致相同。   
2.HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，TreeSet存在的唯一原因是它可以维持元素的排序状态，
所以，只有当需要一个排好序的Set时，才应该使用TreeSet，因为其内部结构支持排序，并且因为迭代是我们更有可能执行的操作，
所以，用TreeSet迭代通常比用HashSet要快，注意，对于插入操作，LinkedHashSet比HashSet的代价更高，这是由维护链表所
带来额外开销造成的。  
3.除了IdentityHashMap，所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢，但是，查找的代价通常比插入要小得多，
HashTable与HashMap性能大体相当，因为HashMap是用来替换HashTable的，因此，它们使用了相同的底层存储和查找机制，
TreeMap通常比HashMap要慢，与使用TreeSet一样，TreeMap是一种创建有序列表的方式，输的行为是：总是保证有序，并且不必
进行特殊的排序，一旦你填充了一个TreeMap，就可以调用KeySet()方法来获取键的Set试图，然后调用toArray()来产生由这些键
构成的数组，之后，你可以使用静态方法Arrays.binarySearch()在排序数组中快速查找对象，LinkedHashMap在插入时比HashMap
慢一点，因为它维护散列数据结构的同时还要维护链表（以保持插入顺序），正是由于这个列表，使得其迭代速度更快。IdentityHashMap
则具有完全不同的性能，因为它使用==而不是equals()来比较元素。   
4.HashMap的性能因子：（默认负载因子是0.75，只有当表达到四分之三满时，才进行再散列，这个因子在时间和空间代价之间达到
了平衡，更高的负载因子可以降低表所需的空间，但是会增加查找代价）   
1）容量：表中的桶位数；   
2）初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器；   
3）尺寸：表中当前存储的项数；   
4）负载因子：尺寸/容量。空表的负载因子是0，而半满表的负载因子是0.5，依此类推，负载轻的表产生冲突的可能性小，因此对于
插入和查找都是最理想的（但会减慢使用迭代器进行遍历的过程），HashMap和HashSet都具有允许你指定负载因子的构造器，表示
当负载情况达到该负载因子的水平时，容器将自动增加其容量（桶位数），实现方式是使容量大致加倍，并重新将现有对象分布到新
的桶位集中（这被成为再散列）。
### 17.11 实用方法
1.Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容，Java容器类库采用快速报错（fail-fast）机制，它
会探查容器上的任何除了你的进程所进行的操作以外的所有变化，一旦它发现其他进程修改了容器，就会立刻抛出ConCurrentModificationExcetpion
异常，即，不是使用复杂的算法在事后来检查问题。   
### 17.12 持有引用
### 17.13 Java 1.0/1.1 的容器
### 17.14 总结
