# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 18 Java I/O系统
### 18.1 File类
1.java使用File类表示操作系统上文件系统中的文件或目录，换句话说，我们可以使用File操作硬盘上的文件或目录，File可以描
述文件或目录的名字，大小等信息不能对文件内容操作！。   
2."."代表的路径：当前目录，项目所处的目录。   
3.File类不仅仅代表存在的文件或目录，也可以用File对象来创建新的目录或者尚不存在的整个目录路径，我们还可以查看文件的
特性（如：大小，最后修改时间，读/写），检查某个File对象代表的是一个文件还是一个目录，并可以删除文件。   
### 18.2 输入和输出
1.流：它代表任何有能力产出数据的数据源对象或者是有能力接受数据的接受端对象。   
2.任何自InputStream或Reader派生而来的类都含有名为read()的基本方法，用于读取单个字节或者字节数组，同样，任何自OutputStream
或Writer派生而来的类都含有名为write()的基本方法，用于写单个字节或者字节数组。（java中流类库让人迷惑的主要原因就在
于：创建单一的结果流，却需要创建多个对象）。  
### 18.3 添加属性和有用的接口
### 18.4 Reader和Writer
1.InputStream和OutputStream在以面向字节形式的I/O中仍可以提供极有价值的功能，Reader和Writer则提供兼容Unicode与
面向字符的I/O功能。   
2.InputStreamReader可以把InputStream转换成Reader，OutputStreamWriter可以把OutputStream转换成Writer。   
3.设计Reader和Wirter继承层次结构主要是为了国际化。
### 18.5 自我独立的类：RandomAccessFile
### 18.6 I/O流的典型使用方式
1.缓冲往往能显著的增加I/O操作的性能。   
### 18.7 文件读写的实用工具
### 18.8 标准I/O
### 18.9 进程控制
### 18.10 新I/O
1.JDK 1.4的java.nio.*包中引入了新的Java I/O类库，其目的在于提高速度，实际上，旧的I/O包已经使用nio重新实现过了，
以便充分利用这种速度提高，因此，即使我们不显式地用nio编写代码，也能从中收益。   
2.速度的提高来自于所使用的结构更接近于操作系统执行I/O方式：通道和缓冲器。   
3.我们可以把它想像成一个煤矿，通道是一个包含煤层（数据）的矿藏，而缓冲器则是派送到矿藏的卡车，卡车载满煤炭而归，我们
再从卡车上获得煤炭，也就是说，我们并没有直接和通道交互，我们只是和缓冲器交互，并把缓冲器派送到通道，通道要么从缓冲器
获得数据，要么向缓冲器发送数据。   
4.唯一直接与通道交互的缓冲器是ByteBuffer。   
5.如果想把一个字节数组写到文件中去，那么就应该使用ByteBuffer.wrap()方法把字节数组包装起来，然后用getChannel()方
法在FileOutputStream上打开一个通道，接着将来自于ByteBuffer的数据写到FileChannel中。注意：ByteBuffer是将数据移
进移出通道的唯一方式。   
### 18.11 压缩
### 18.12 对象序列化
1.当创建对象时，只要你需要它就会一直存在，但在程序中止时，无论如何都不会继续存在，但是如果能对象在程序不运行的情况下
仍能存在并保存其信息，那将非常有用。   
2.Java的对象序列化将哪些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的
对象，这一过程甚至可以通过网络进行，这意味着序列化机制能够自动弥补不同操作系统之间的差异。   
3.对象序列化的概念加入到语言中是为了支持两种主要特性，一是，Java的远程方法调用，通过序列化保持对象，再者，对JavaBean
来说，一般情况下是在设计阶段对它的状态信息进行配置，这种状态信息必须保存下来，并且在程序启动时进行后期恢复，这种具体
工作就是由对象序列化完成的。
### 18.13 XML
### 18.14 Preferences
