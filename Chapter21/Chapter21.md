# Thinking in java(Fourth Edition)
    thinking in java notes
## Chapter 21 并发 
### 21.1 并发的多面性
1.并发是用于多处理器编程的基本工具。   
2.Java采取了更加传统的方式，在顺序型语言的基础上提供对多线程的支持。   
3.Java的线程机制是抢占式的。   
4.一个线程就是在进程中的一个单一的顺序控制流。   
### 21.2 基本的线程机制
1.线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口来提供，要想定义任务，只需要实现Runnable接口
并编写run()方法，使得该任务可以执行你的命令。   
2.任务的run()方法通常会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定跳出循环的条件（有一种选择是直
接从run()返回）。   
3.在run()中对静态方法Thread.yield()的调用是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转移给另一个线
程）的一种建议，它在声明；"我已经执行完生命周期中最重要的不分了，此刻正是切换给其他任务执行一段时间的大好时机。"
4.当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处，它不会产生任何内在的线程能力，要实现线
程行为，你必须显式地将一个任务附着到线程上。   
5.将Runnable对象转变成为工作任务的传统方式就是把它提供给一个Thread构造器。   
6.Thread构造器只需要一个Runnable对象，调用Thread对象的start()方法为该线程执行必须的初始化操作，然后调用Runnable
的run()方法，以便在这个新线程中启动该任务。
7.CacheThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理
的Executor的首选，SingleThreadExecutor就像是线程数量为1的FixedThreadPool，它还提供了一种重要的并发保证，其他
线程不会（即没有两个线程会）被并发调用，这会改变任务的加锁需求。   
8.Runnable是执行工作的独立任务，但是它不返回任何值，如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口
，Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()（而不是run()）中返回的值，并且必须使用
ExecutorService.submit()方法调用它。   
9.线程的优先级将该线程的重要性传递给了调度器，尽管CPU处理现有线程集的顺序不是确定的，但是调度器将倾向于让优先级高的
线程先行，优先级较低的线程仅仅是执行的频率较低，在绝大多数时间里，所有线程都应该以默认的优先级运行，试图操纵线程优先级
通常是一种错误。   
10.JDK有10个优先级。   
11.后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分，
因此，当所有的非后台线程结束时，程序也就中止了，同时会杀死进程中的所有后台线程，反过来说，只要有任何非后台线程还在运
行，程序就不会终止。   
12.一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行，如果某个线程在另一个
线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复（即t.isAlive()返回为假），也可以在调用join()时带上
一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。
对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch子句。 
### 21.3 共享受限资源
1.原子性：诸如赋值和返回值这样的简单操作在发生时没有中断的可能，因此你不会看到这个域处于在执行这些简单操作的过程中的
中间状态。   
2.一个任务不能依赖于另一个任务，因为任务关闭的顺序无法得到保证，这里通过使任务依赖于非任务对象，我们可以消除潜在的竞
争条件。   
3.基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问资源的方案，这意味着在给定时刻只允许一个任务访问共
享资源，通常这是通过在代码前面加上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码，因为锁语句产
生了一种互相排斥的效果，所以这种机制常常称为互斥量（mutex）。   
4.一个任务可以多次获得对象的锁，JVM负责跟踪对象被加锁的次数，如果一个对象被解锁（即锁被完全释放），其计数变为0，在任
务第一次给对象加锁的时候，计数变为1，每当这个相同的任务在这个对象上获得锁时，计数都会递增，显然，只有首先获得了锁的任
务才能允许继续获取多个锁，每当任务离开一个synchronized方法，计数递减，当计数为0时，锁被完全释放，此时别的任务就可以
使用此资源。   
5.每个访问临界共享资源的方法都必须被同步，否则它们就不会正确的工作。   
6.Lock对象必须被显式地创建，锁定和释放，它与内建的锁形式相比，代码缺乏优雅性，注意，return子句必须在try子句内，以确
保unlock()不会过早的发生，从而将数据暴露给了第二个任务。   
7.如果使用synchronized关键字时，某些事物失败了，就会抛出一个异常，但是你没有机会去做任何清理工作，以维护系统使其处于
良好的状态，有了显式的lock()对象，你就可以使用finnaly()子句将系统维护在正确的状态了，大体上，当你使用synchronized
时，需要写的代码量很少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才会使用显式的Lock对象，例如：
用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它。   
8.ReentrantLock允许你尝试着获取但最终未获取锁，这样如果其他人已经获取了这个锁，那么你就可以决定离开去执行其他一些事
情，而不是等待直至这个锁被释放。显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了你更多细
粒度的控制力，这对于实现专有同步结构时很有用的，例如用于遍历链接列表中的节点的节节传递的加锁机制（也称为锁耦合），这种
遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁。   
9.原子操作是不能被其他线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的，上下文切换之前（切换到其他线
程执行）执行完毕。依赖原子性是很危险的工作。   
10.原子性可以应用于除long和double之外的所有基本类型之上的"简单操作"，对于读取和写入除long和double之外的基本类型变
量这样的操作，可以保证它们会被当作不可分（原子）的操作来操作内存，但是JVM可以将64位（long和double变量）的读取和写入
当作两个分离的32位操作来执行，这就产生在一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结果的
可能性（这有时被称为字撕裂，因为你可能会看到部分被修改过的数值），但是当你定义long和double变量时，如果使用volatile
关键字，就会获得（简单的赋值与返回操作的）原子性。   
11.volatile关键字还确保了应用中的可视性，如果你将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的
读操作就都可以看到这个修改。如果多个任务在同时访问某个域，那么这个域应该是volatile的，否则，这个域就应该只能经由同步
来访问，同步也会导致向主存中刷新，因此如果一个域完全有synchronized方法或语句块来防护，那就不必将其设置为是volatile
的。当一个域的值依赖于它之前的值时（例如递增一个计数器），volatile就无法工作，如果某个域的值受到其他域的值的限制，那
么volatile也无法工作。使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。   
12.什么才属于原子操作呢？ 对域中的值做赋值和返回操作通常都是原子性的。   
13.如果你将一个域定义为volatile，那么它就会告诉编译器不要执行任何移除读取和写入操作的优化，这些操作的目的是用线程中
的局部变量维护这个域的精确同步。   
### 21.4 终结任务
1.一个线程可以处于以下四种状态之一：   
1）新建（new）：当线程被创建时，它只会短暂地处于这种状态，此时它已经分配了必需的系统资源，并执行了初始化，此刻线程已
经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态；   
2）就绪（runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行，也就是说，在任意时刻，线程可以运行
也可以不运行，只要调度器能分配时间片给线程，它就可以运行，这不同于死亡和阻塞状态；   
3）阻塞（blocked）：线程能够运行，但有某个条件阻止它的运行，当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任
何CPU时间，直到线程重新进入了就绪状态，它才有可能执行操作；   
4）死亡（dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或不再是可运行
的，任务死亡的通常方式是从run()方法返回。    
2.一个任务进入阻塞状态，可能有如下原因：
1）通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任何在指定的时间内不会运行；   
2）你通过调用wait()使线程挂起，直到线程得到了notify()或notifyAll()消息（或者在Java SE5的java.util.concurrent
类库中等价的signal()和signalAll()消息，线程才会进入就绪状态）；   
3）任务在等待某个输入/输出完成。   
4）任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁；   
3.你能够中断对sleep()的调用，I/O和在Synchronized块上的等待是不可中断的，解决方案是关闭任务在其上发生阻塞的底层资
源，一旦底层资源被关闭，任务将接触阻塞，各种nio类提供了更人性化的I/O中断，被阻塞的nio通道会自动地响应中断。   
### 21.5 线程之间的协作
1.当你使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的
资源，也就是说，如果两个任务在交替着步入某项共享资源（通常是内存），你可以使用互斥来使得任何时刻只有一个任务可以访问
这项资源。   
2.wait()会在等待外部世界产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即表示发生了某些感兴趣
的事物，这个任务才会被唤醒并去检查所产生的变化，因此，wait()提供了一种在任务之间对活动同步的方式。   
3.当一个任务在方法里遇到了对wait()的调用的时候，线程的执行被挂起，对象上的锁被释放，因为wait()将释放锁，这就意味着
另一个任务可以获得这个锁，因此在该对象（现在时未锁定的）中的其他synchronized方法可以在wait()期间被调用，这一点至关
重要，因为这些其他的方法通常将会产生改变吗，而这种改变正是使被挂起的任务重新唤醒所感兴趣的变化，因此，当你调用wait()
时，就是在声明：我已经刚刚做完所能做的所有事情，因此我要在这里等待，但是我希望其他的synchronized操作在条件适合的情
况下能够执行。   
4.有两种形式的wait()，第一种版本接受毫秒作为参数，含义与sleep()方法里参数的意思相同，都是指"在此期间暂停"，但是与
sleep()不同的是，对于wait()而言：1）在wait()期间对象锁是释放的；2）可以通过notify(),notifyAll()或者令时间到期
从wait()中恢复执行。第二种，也是更常用形式的wait()不接受参数，这种wait()将无限等待下去，直到线程接收到notify()或
notifyAll()的消息。   
5.wait()，notify(),notifyAll()有一个比较特殊的方面，那就是这些方法是基类Object的一部分，而不是属于Thread的一部
分，因为这些方法操作的是锁也是所有对象的一部分，所以，你可以把wait()放进任何同步控制方法里，而不用考虑这个类是继承自
Thread还是实现了Runnable，实际上，只能在同步控制方法或者同步控制块里调用wait()，notify(),notifyAll()（因为不用
操作锁，所以sleep()可以在非同步控制方法里调用）,如果在非同步控制方法里调用这些方法，程序能通过编译，但是运行的时候，
将得到IllegalmonitorStateException异常，并伴随这一些含糊的信息，比如"当前线程不是拥有者"，消息的意思是，调用wait()，
notify(),notifyAll()的任务在调用这些方法前必须"拥有"（获得）对象锁。   
### 21.6 死锁
1.当同时满足下面四个条件时，就会发生死锁：   
1）互斥条件。任何使用的资源中至少有一个是不能共享的。这里，一根Chopstick一次就只能被一个Philosopher使用；   
2）至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源，也就是说，要发生死锁，Philosopher必
须拿着一根筷子并且等待另一根；   
3）资源不能被任务抢占，任务必须把走远释放当作普通事件，哲学家很有礼貌，他们不会从其他哲学家哪里强筷子；   
4）必须有循环等待，这时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去直到有一个
任务在等待第一个任务所持有的资源，使得大家都被锁住。因为每个哲学家都试图先得到右边的筷子，然后得到左边的筷子，所以发
生了循环等待。    
2.要发生死锁的话，所有这些条件必须全部满足，所以要防止死锁的话，只需破坏其中一个即可，最容易的是第四个。    
### 21.7 新类库中的构件
### 21.8 仿真
### 21.9 性能调优
1.使用Lock通常会比使用Synchronized要高效许多，而且Synchronized的开销看起来变化范围太大，而Lock相对比较一致,这是
否意味着你永远都不应该使用Synchronized关键字呢？这里有两个因素需要考虑：第一，在SynchronizationComparisons.java，
互斥方法的方法体是非常小的，通常这是一个很好的习惯，只互斥那些你绝对必须互斥的部分，但是实际中，被互斥部分可能会比上面
示例中的那些大许多，因此在这些方法体中话费的时间百分比可能会明显大雨进入和退出互斥的开销，这样也就湮没了提高互斥速度
带来的所有好处，第二，Synchronized关键字所产生代码，与Lock所需的"加锁-try/finally-解锁"惯用法所产生的代码相比，
可读性提高了许多，因此：以Synchronized关键字入手，只有性能调优时才替换为Lock对象这种做法，才具有实际意义。   
2.Atomic对象只有在非常简单的情况下才有用，这些情况通常包括你只有一个要被修改的Atomic对象，并且这个对象独立于其他所
有的对象，更安全的额做法是：以更加传统的互斥方式入手，只有在性能方面的需求能够明确指示时，再更换为Atomic。   
3.这些免锁容器背后的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可
（CopyOnWriteArrayList）。   
### 21.10 活动对象
